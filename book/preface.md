# 数据结构入门（Go语言描述）

本作将讨论几类经典数据结构以及相关算法的特点，内容主要源于作者在学习和工作中的小小心得。我们希望借此与诸君共勉。

我们并不打算编写一部专著，毕竟已有珠玉在前。相对于严谨的论证，这里更倾向于提供直观的描述，而选用Go语言则有助于去繁就简。

## 关于算法复杂度
谈及数据结构，很多时候我们关心的其实不是数据结构本身，而是维护和利用这些数据结构的算法。而谈到算法，就不可避免地要涉及算法复杂度的问题。

我们从时间和空间两方面讨论算法复杂度，且通常更关心时间复杂度。这两方面的复杂度实际上分别反映了算法对处理器和存储器资源的消耗情况，它们是执行算法的主要开销。在考虑平均开销的同时，往往还要考虑最坏情况下的开销，以便满足特定的应用场景。 

算法的开销一般与其所处理的数据规模呈正相关。我们设N为数据规模，k为正整数，那么常见的复杂度级别可表示为O(1)、O(logN)、O(N<sup>k</sup>)、O(2<sup>N</sup>)，以及它们的组合（如O(NlogN) = O(N) × O(logN)）。当数据规模比较大时，不同级别间的差距相当惊人。打个比方，如果说O(logN)是拳脚功夫，那么O(N<sup>k</sup>)可比烈性炸药，至于O(2<sup>N</sup>)，则堪比原子裂变。O(1)则比较特殊，表示复杂度与数据规模无关，是最低的级别。

下图显示了O(logN)、O(N)、O(NlogN)、O(N<sup>2</sup>)、O(N<sup>3</sup>)、O(2<sup>N</sup>)等级别函数的增长曲线。  
![](images/preface.png)

考虑到要系统地阐释复杂度理论需要相当的篇幅，我们在此点到即止，有兴趣的读者请自行补完。

---
[返回目录](index.md)