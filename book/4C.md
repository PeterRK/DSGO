# 弱AVL树
　　AVL树的约束条件比较强，以至于删除节点时所需结构变换次数达O(logN)，劣于红黑树（实际使用中AVL树整体性能不逊于未做平衡因子压缩的红黑树）。为了弥补这点遗憾，发展出了约束弱化的AVL树变种。
```go
type node[T constraints.Ordered] struct {
    lDiff  uint8
    rDiff  uint8
    key    T
    parent *node[T]
    left   *node[T]
    right  *node[T]
}
```
弱AVL树节点分别记录与两个子节点的逻辑高度差，并要求满足如下三则约束：

 - nil的高度为-1
 - 当节点为叶节点（子节点皆为nil）时，高度必须为0
 - 节点和子节点的高度差为1或2

对比AVL树可以发现，约束弱化后放松了如下两个点：

 - 非叶节点和nil之间的高度差可以为2
 - 非叶节点可以和左右子节点的高度差皆为2（AVL树的平衡因子只能表示12、11、21三种情况）

### 存在意义
　　显然，AVL树本身满足弱AVL树的约束，另外也可以证明弱AVL树能转成红黑树（请查阅相关文献，此处不展开），故弱AVL树是一种介乎于AVL树和红黑树之间的数据结构。  

## 插入与再平衡
```
----------------LL型---------------    -----------------LR型----------------
|    X0 - P      |       X        |    |      X0 - P     |        Z        |
|   / \    \     |      / \       |    |     / \    \    |      /   \      |
| Y1   \    \    |    Y1   P1     |    |    /   Z1   \   |    X1     P1    |
|       \    \   |        /  \    |    |   /   /  \   \  |   /  \   /  \   |
|        Z2   S2 |      Z1    S1  |    | Y2   a    b  S2 | Y1    a b    S1 |
```
弱AVL树的插入和AVL树相似，差别在于再平衡过程，其中平衡因子的调整并没有那么直观。
```go
func (tr *Tree[T]) rebalanceAfterInsert(P *node[T], key T) {
    for {
        super, root := P.parent, (*node[T])(nil)
        if key < P.key {
            if P.lDiff--; P.lDiff > 0 { break }     //无修正中止
            if P.rDiff == 1 {
                P.lDiff, P.rDiff = 1, 2
                goto Lup                            //回溯修正高度
            }
            if X := P.left; X.lDiff == 1 {
                P.left = P.Hook(X.right)
                X.right = X.hook(P)
                P.lDiff, P.rDiff, X.rDiff = 1, 1, 1
                root = X                            //LL型
            } else {
                Z := X.right
                X.right, P.left = X.Hook(Z.left), P.Hook(Z.right)
                Z.left, Z.right = Z.hook(X), Z.hook(P)
                X.rDiff, P.lDiff = Z.lDiff, Z.rDiff
                X.lDiff, P.rDiff = 1, 1
                Z.lDiff, Z.rDiff = 1, 1
                root = Z                             //LR型
            }
        } else {
            //...
        }
        tr.hookSubTree(super, root)
        break
    Lup:
        if P = super; P == nil { break }
}   }
```

## 删除与再平衡
```
----------------LL型----------------    ----------------LR型----------------
|       P        |       S         |    |       P        |        Z        |
|      / \       |      / \        |    |      / \       |       / \       |
|    S1   \      |     /   \       |    |     S1  \      |      /   \      |
|   /  \   \     |    /     P1+    |    |    / \   \     |     /     \     |
| Y1    \   \    |  Y2     /  \    |    |   /   Z1  \    |    S2      P2   |
|       Z?   \   |       Z?    \   |    |  /   / \   \   |   /  \    / \   |
|             X3 |             X2- |    | Y2  a   b   X3 |  Y1   a  b   X1 |
```
删除过程略为复杂，不过全程只需要一次结构变换，比红黑树还要少。
```go
func (tr *Tree[T]) rebalanceAfterRemove(P *node[T], key T) {
    for {
        super, root := P.parent, (*node[T])(nil)
        if key > P.key {
            if P.rDiff++; P.rDiff == 2 { break }    //无修正中止
            if P.lDiff == 2 {
                P.lDiff, P.rDiff = 1, 2
                goto Lup                            //回溯修正高度case1
            }
            if S := P.left; S.lDiff == 2 {
                if S.rDiff == 2 {
                    S.lDiff, S.rDiff, P.rDiff = 1, 1, 2
                    goto Lup                        //回溯修正高度case2
                }
                Z := S.right
                S.right, P.left = S.Hook(Z.left), P.Hook(Z.right)
                Z.left, Z.right = Z.hook(S), Z.hook(P)
                S.rDiff, P.lDiff = Z.lDiff, Z.rDiff
                S.lDiff, P.rDiff = 1, 1
                Z.lDiff, Z.rDiff = 2, 2 
                root = Z                            //LR型
            } else {
                X, Z := P.right, S.right
                S.right = S.hook(P)
                P.lDiff, S.rDiff = S.rDiff, 1
                S.lDiff, P.rDiff = 2, 2
                if Z == nil {
                    P.left = nil
                    if X == nil {                   //叶节点需要特别处理
                        S.rDiff, P.lDiff, P.rDiff = 2, 1, 1
                    }
                } else {
                    P.left = P.hook(Z)
                }
                root = S                            //LL型
            }
        } else {
            //...
        }
        tr.hookSubTree(super, root)
        break
    Lup:
        if P = super; P == nil { break }
}   }
```

## 性能评估
采用一轮插入+三分之二量删除+三分之二量有值查找+三分之一量无值查找的测试方法。

| 操作 | SkipList | B+ Tree | RB-Tree | AVL-Tree | WAVL-Tree |
| :-------|:----:|:----:|:----:|:----:|:----:|
| Insert | 24.65ms | 12.59ms | 19.71ms | 20.92ms | 19.66ms |
| Search | 23.96ms | 10.18ms | 12.27ms | 11.53ms | 12.11ms |
| Remove | 16.91ms | 8.51ms | 10.07ms | 10.21ms | 10.48ms |

十万随机整数测试，B+树的插入性能有显著优势，二叉树三家各有千秋，跳跃链表全面落后。

| 操作 | SkipList | B+ Tree | RB-Tree | AVL-Tree | WAVL-Tree |
| :-------|:----:|:----:|:----:|:----:|:----:|
| Insert | 506.90ms | 175.64ms | 425.14ms | 420.90ms | 425.22ms |
| Search | 560.65ms | 147.18ms | 287.62ms | 278.46ms | 286.28ms |
| Remove | 421.95ms | 119.71ms | 316.01ms | 287.45ms | 294.77ms |

百万随机整数测试，B+树全面碾压对手，跳跃链表继续落后。  
AVL树凭借更好的平衡性小超红黑树，弱AVL树的表现介于AVL树和红黑树之间。

### 评估结论
　　AVL树和红黑树之争由来已久，其实删除过程中结构调整次数对两者间胜负的影响微乎其微，决定胜负的更多是平衡性以及平衡因子的维护。B+树在大数据量下是无可争议的性能王者，不过它并不属于二叉搜索树家族，具体将会在下一节介绍。跳跃链表在核心查找性能上和平衡树有较大差距，目前看不到逆袭的希望。

---
[目录](../README.md)　[上一节](4B.md)　[下一节](4D.md)