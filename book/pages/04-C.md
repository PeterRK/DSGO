# 布隆过滤器
上一节我们讨论了通过多路Hash减少来减少Hash冲突的办法，本节我们将把它推至极致。

## 位向量
　　布隆过滤器的核心结构是一个位向量，即比特数组。由于存储器的最小数据单位是字节，我们需要通过在字节数组的基础上添加额外操作来实现位向量的功能。
```go
    type BloomFliter struct {
        core [VEC_SZIE]byte                 //位向量
    }
    func (tb *BloomFliter) setBit(index uint) {
        tb.core[index>>3] |= (byte(1) << (index & 7))
    }
    func (tb *BloomFliter) testBit(index uint) bool {
        bit := tb.core[index>>3] & (byte(1) << (index & 7))
        return bit != byte(0)
    }
```

## 多路合一
　　布隆过滤器使用了多路Hash，但没有使用多个Hash表，每次Hash都在同一个表中做一个比特的标记。通过检验一个元素的各路Hash结果是否在表中都有记录，可以推断该元素是否被登记在案。这样做显然不是严谨的，会有一定几率的误判（但不存在漏网），误判率p与容积率n/m（n为元素个数，m为表容量）有关：

    一个元素被误判存在的概率为其各路Hash指向位置都已被标记的概率，设共有x路Hash，则
    p = (1 - (1 - 1/m)^(nx))^x
    由 ln(1+x) = x - x^2/2 + x^3/3 - x^4/4 +... 知当m较大时 ln(1-1/m) ≈ -1/m
    故 (1-1/m)^m = e^(m ln(1-1/m)) = 1/e，继而
    p = (1 - 1/e^ax)^x，其中 a = n/m
    令 y = 1/e^ax，则 p = (1-y) ^ -ln(y)/a
    对p(y)求导，得 p' = ((1-y) ^ -ln(y)/a)(ln(y)/(1-y) - ln(1-y)/(y)) / a
    因x为正整数且a为正数，故 y ∈ (0,1)
    可知p'的正负取决于 f = ln(y)/(1-y) - ln(1-y)/(y)
    又由 f' = ((1-y)/y + ln(y))/(1-y)^2 + (y/(1-y) + ln(1-y))/y^2 > 0 知f单调递增
    因此，当y∈(0,1/2)时p'<0，当y∈(1/2,1)时p'>0
    进一步可知当y=1/2时，p有最小值 1/2^(ln(2)/a)
    此时路数 x = ln(2)/a 为最佳，反之由误判率可推算容积率 n/m = a = (ln(2))^2/(-ln(p))
    设 p = 1/2^w，则 n/m = ln(2)/w ≈ 0.7/w

　　当容积率为1/10时，期望误判率p约为1/120，而当容积率为1/20时，p降至约1/15000。

---
[目录](../index.md)　[上一节](04-B.md)　[下一节](04-D.md)
